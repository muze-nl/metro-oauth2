{"mappings":"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","sources":["<anon>","src/browser.mjs","src/oauth2.mjs","src/oauth2.mockserver.mjs","src/oauth2.pkce.mjs","src/oauth2.discovery.mjs"],"sourcesContent":["var $16ZAN$muzenlmetro = require(\"@muze-nl/metro\");\nvar $16ZAN$muzenlassert = require(\"@muze-nl/assert\");\nvar $16ZAN$muzenlmetrosrcmwjsonmjs = require(\"@muze-nl/metro/src/mw/json.mjs\");\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $dcc128ad0af646ff$exports = {};\n\n$parcel$defineInteropFlag($dcc128ad0af646ff$exports);\n\n$parcel$export($dcc128ad0af646ff$exports, \"default\", () => $dcc128ad0af646ff$export$2e2bcd8739ae039);\n\n\n\nfunction $dcc128ad0af646ff$export$2e2bcd8739ae039(options) {\n    let site = \"default\";\n    if (options.site) site = options.site;\n    let localState, localTokens;\n    if (typeof localStorage !== \"undefined\") {\n        localState = {\n            get: ()=>localStorage.getItem(\"metro/state:\" + site),\n            has: ()=>localStorage.getItem(\"metro/state:\" + site),\n            set: (value)=>localStorage.setItem(\"metro/state:\" + site, value)\n        };\n        localTokens = {\n            get: (name)=>localStorage.getItem(site + \":\" + name),\n            set: (name, value)=>localStorage.setItem(site + \":\" + name, value),\n            has: (name)=>localStorage.hasItem(site + \":\" + name)\n        };\n    } else {\n        let stateMap = new Map();\n        localState = {\n            get: ()=>stateMap.get(\"metro/state:\" + site),\n            has: ()=>stateMap.get(\"metro/state:\" + site),\n            set: (value)=>stateMap.set(\"metro/state:\" + site, value)\n        };\n        localTokens = new Map();\n    }\n    const oauth2 = {\n        tokens: localTokens,\n        state: localState,\n        endpoints: {\n            authorize: \"/authorize\",\n            token: \"/token\"\n        },\n        callbacks: {\n            authorize: (url)=>document.location = url\n        },\n        client: $16ZAN$muzenlmetro.client().with((0, ($parcel$interopDefault($16ZAN$muzenlmetrosrcmwjsonmjs)))()),\n        client_id: \"\",\n        client_secret: \"\",\n        redirect_uri: \"\",\n        grant_type: \"authorization_code\",\n        force_authorization: false\n    };\n    for(let option in options){\n        switch(option){\n            case \"access_token\":\n            case \"authorization_code\":\n            case \"refresh_token\":\n                oauth2.tokens.set(option, options[option]);\n                break;\n            case \"client\":\n            case \"client_id\":\n            case \"client_secret\":\n            case \"grant_type\":\n            case \"force_authorization\":\n            case \"redirect_uri\":\n                oauth2[option] = options[option];\n                break;\n            case \"state\":\n            case \"tokens\":\n                if (typeof options[option].set == \"function\" && typeof options[option].get == \"function\" && typeof options[option].has == \"function\") oauth2[option] = options[option];\n                else if (option == \"tokens\" && typeof options.tokens == \"object\") for(let token in options.tokens)oauth2.tokens.set(token, options.tokens[token]);\n                else if (option == \"state\" && typeof options.state == \"object\") {\n                    if (!options.state.random) options.state.random = createState(40);\n                    oauth2.state.set(JSON.stringify(options.state));\n                } else throw $16ZAN$muzenlmetro.metroError(\"metro/mw/oauth2: incorrect value for \" + option);\n                break;\n            case \"endpoints\":\n                for(let endpoint in options.endpoints){\n                    if (endpoint != \"authorize\" && endpoint != \"token\") throw $16ZAN$muzenlmetro.metroError('Unknown endpoint, choose one of \"authorize\" or \"token\"', endpoint);\n                }\n                Object.assign(oauth2.endpoints, options.endpoints);\n                break;\n            case \"callbacks\":\n                for(let callback in options.callbacks){\n                    if (callback != \"authorize\") throw $16ZAN$muzenlmetro.metroError('Unknown callback, choose one of \"authorize\"', callback);\n                }\n                Object.assign(oauth2.callbacks, options.callbacks);\n                break;\n            default:\n                throw $16ZAN$muzenlmetro.metroError(\"Unknown oauth2mw option \", option);\n        }\n        if (!oauth2.redirect_uri) oauth2.redirect_uri = typeof window !== \"undefined\" ? window.location?.href : \"\";\n        if (oauth2.redirect_uri) oauth2.redirect_uri = $16ZAN$muzenlmetro.url(oauth2.redirect_uri).with(\"?metroRedirect=true\");\n    }\n    /**\n\t * This is the middleware function. It will intercept a request, and if needed\n\t * go through the OAuth2 authorization flow first.\n\t */ return async function(req, next) {\n        if (oauth2.force_authorization) return oauth2authorized(req, next);\n        let res = await next(req);\n        if (res.ok) return res;\n        switch(res.status){\n            case 400:\n            case 401:\n                return oauth2authorized(req, next);\n        }\n        return res;\n    };\n    /**\n\t * Implements the OAuth2 authorization flow for a request\n\t */ async function oauth2authorized(req, next) {\n        getTokensFromLocation();\n        if (!oauth2.tokens.has(\"access_token\")) {\n            let token = await fetchAccessToken(req);\n            if (!token) return $16ZAN$muzenlmetro.response(\"false\");\n            return oauth2authorized(req, next);\n        } else if (isExpired(req)) {\n            let token = await fetchRefreshToken(req);\n            if (!token) return $16ZAN$muzenlmetro.response(\"false\");\n            return oauth2authorized(req, next);\n        } else {\n            let accessToken = oauth2.tokens.get(\"access_token\");\n            req = $16ZAN$muzenlmetro.request(req, {\n                headers: {\n                    Authorization: accessToken.type + \" \" + accessToken.value\n                }\n            });\n            return next(req);\n        }\n    }\n    /**\n\t * Fetches and stores the authorization_code from a redirected URI\n\t * Then removes the authorization_code from the browser URL\n\t */ function getTokensFromLocation() {\n        if (typeof window !== \"undefined\" && window?.location) {\n            let url = $16ZAN$muzenlmetro.url(window.location);\n            let code, state, params;\n            if (url.searchParams.has(\"code\")) {\n                params = url.searchParams;\n                url = url.with({\n                    search: \"\"\n                });\n                history.pushState({}, \"\", url.href);\n            } else if (url.hash) {\n                let query = url.hash.substr(1);\n                params = new URLSearchParams(\"?\" + query);\n                url = url.with({\n                    hash: \"\"\n                });\n                history.pushState({}, \"\", url.href);\n            }\n            if (params) {\n                code = params.get(\"code\");\n                state = params.get(\"state\");\n                let storedState = oauth2.state.get(\"metro/state\");\n                if (!state || state !== storedState) return;\n                if (code) oauth2.tokens.set(\"authorization_code\", code);\n            }\n        }\n    }\n    /**\n\t * Fetches the access_token. If the authorization_code hasn't been retrieved yet,\n\t * it will first try to get that, using the oauth2.callbacks.authorize function.\n\t * If a refresh_token is also returned, it will store that in the oauth2.tokens storage.\n\t */ async function fetchAccessToken(req) {\n        if (oauth2.grant_type === \"authorization_code\" && !oauth2.tokens.has(\"authorization_code\")) {\n            let authReqURL = getAuthorizationCodeURL();\n            if (!oauth2.callbacks.authorize || typeof oauth2.callbacks.authorize !== \"function\") throw $16ZAN$muzenlmetro.metroError(\"oauth2mw: oauth2 with grant_type:authorization_code requires a callback function in client options.oauth2.callbacks.authorize\");\n            let token = await oauth2.callbacks.authorize(authReqURL);\n            if (token) oauth2.tokens.set(\"authorization_code\", token);\n            else return $16ZAN$muzenlmetro.response(false);\n        }\n        let tokenReq = getAccessTokenURL();\n        let response = await oauth2.client.get(tokenReq);\n        if (!response.ok) throw $16ZAN$muzenlmetro.metroError(response.status + \":\" + response.statusText, await response.text());\n        let data = await response.json();\n        oauth2.tokens.set(\"access_token\", {\n            value: data.access_token,\n            expires: getExpires(data.expires_in),\n            type: data.token_type,\n            scope: data.scope\n        });\n        if (data.refresh_token) {\n            let token = {\n                value: data.refresh_token\n            };\n            oauth2.tokens.set(\"refresh_token\", token);\n        }\n        return data;\n    }\n    /**\n\t * Fetches a new access_token using a stored refresh_token\n\t * If a new refresh_token is also returned, it will update the stored refresh_token\n\t */ async function fetchRefreshToken(req, next) {\n        let refreshTokenReq = getAccessTokenURL(\"refresh_token\");\n        let response = await oauth2.client.get(refreshTokenReq);\n        if (!response.ok) throw $16ZAN$muzenlmetro.metroError(response.status + \":\" + response.statusText, await response.text());\n        let data = await response.json();\n        oauth2.tokens.set(\"access_token\", {\n            value: data.access_token,\n            expires: getExpires(data.expires_in),\n            type: data.token_type,\n            scope: data.scope\n        });\n        if (data.refresh_token) {\n            let token = {\n                value: data.refresh_token\n            };\n            oauth2.tokens.set(\"refresh_token\", token);\n        }\n        return data;\n    }\n    /**\n\t * Returns the URL to use to get a authorization_code\n\t */ function getAuthorizationCodeURL() {\n        if (!oauth2.endpoints.authorize) throw $16ZAN$muzenlmetro.metroError(\"oauth2mw: Missing options.endpoints.authorize url\");\n        let url = $16ZAN$muzenlmetro.url(oauth2.endpoints.authorize, {\n            hash: \"\"\n        });\n        $16ZAN$muzenlassert.assert(oauth2, {\n            client_id: /.+/,\n            redirect_uri: /.+/,\n            scope: /.*/\n        });\n        let search = {\n            response_type: \"code\",\n            client_id: oauth2.client_id,\n            redirect_uri: oauth2.redirect_uri,\n            state: oauth2.state || createState(40)\n        };\n        search.client_secret = oauth2.client_secret;\n        if (oauth2.scope) search.scope = oauth2.scope;\n        return $16ZAN$muzenlmetro.url(url, {\n            search: search\n        });\n    }\n    /**\n\t * Creates and stores a random state to use in the authorization code URL\n\t */ function createState(length) {\n        const validChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        let randomState = \"\";\n        let counter = 0;\n        while(counter < length){\n            randomState += validChars.charAt(Math.floor(Math.random() * validChars.length));\n            counter++;\n        }\n        oauth2.state.set(randomState);\n        return randomState;\n    }\n    /**\n\t * Returns a token endpoint URL with all the correct parameters, given the\n\t * grant_type. This can then be used in a metro.get.\n\t */ function getAccessTokenURL(grant_type = null) {\n        $16ZAN$muzenlassert.assert(oauth2, {\n            client_id: /.+/,\n            redirect_uri: /.+/\n        });\n        if (!oauth2.endpoints.token) throw $16ZAN$muzenlmetro.metroError(\"oauth2mw: Missing options.endpoints.token url\");\n        let url = $16ZAN$muzenlmetro.url(oauth2.endpoints.token, {\n            hash: \"\"\n        });\n        let params = {\n            grant_type: grant_type || oauth2.grant_type,\n            client_id: oauth2.client_id\n        };\n        params.client_secret = oauth2.client_secret;\n        if (oauth2.scope) params.scope = oauth2.scope;\n        switch(oauth2.grant_type){\n            case \"authorization_code\":\n                params.redirect_uri = oauth2.redirect_uri;\n                params.code = oauth2.tokens.get(\"authorization_code\");\n                break;\n            case \"client_credentials\":\n                break;\n            case \"refresh_token\":\n                params.refresh_token = oauth2.refresh_token;\n                break;\n            default:\n                throw new Error(\"Unknown grant_type: \".oauth2.grant_type);\n        }\n        return $16ZAN$muzenlmetro.url(url, {\n            searchParams: params\n        });\n    }\n    /**\n\t * Returns true if the access token in a request is expired. False otherwise.\n\t */ function isExpired(req) {\n        if (req.oauth2 && req.oauth2.tokens && req.oauth2.tokens.has(\"access_token\")) {\n            let now = new Date();\n            let token = req.oauth2.tokens.get(\"access_token\");\n            return now.getTime() > token.expires.getTime();\n        }\n        return false;\n    }\n    /**\n\t * Returns a new Date based on a duration, which can either be a date\n\t * or a number of seconds from now.\n\t */ function getExpires(duration) {\n        if (duration instanceof Date) return new Date(duration.getTime()); // return a copy\n        if (typeof duration === \"number\") {\n            let date = new Date();\n            date.setSeconds(date.getSeconds() + duration);\n            return date;\n        }\n        throw new TypeError(\"Unknown expires type \" + duration);\n    }\n}\n\n\nvar $982c9e81107e6258$exports = {};\n\n$parcel$defineInteropFlag($982c9e81107e6258$exports);\n\n$parcel$export($982c9e81107e6258$exports, \"default\", () => $982c9e81107e6258$export$2e2bcd8739ae039);\n\n\nconst $982c9e81107e6258$var$baseResponse = {\n    status: 200,\n    statusText: \"OK\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n};\nconst $982c9e81107e6258$var$badRequest = (error)=>{\n    return {\n        status: 400,\n        statusText: \"Bad Request\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            error: \"invalid_request\",\n            error_description: error\n        })\n    };\n};\nlet $982c9e81107e6258$var$error, $982c9e81107e6258$var$expect, $982c9e81107e6258$var$token;\nlet $982c9e81107e6258$var$pkce = {};\nfunction $982c9e81107e6258$export$2e2bcd8739ae039(options = {}) {\n    // TODO: add PCKE support, so assert either client_secret or code_verifier / code_challenge\n    // store code_challenge and code_challenge_method for each authorization_code\n    // TODO: add DPoP support\n    const defaultOptions = {\n        \"PKCE\": false,\n        \"DPoP\": false\n    };\n    options = Object.assign({}, defaultOptions, options);\n    return (req, next)=>{\n        let url = $16ZAN$muzenlmetro.url(req.url);\n        switch(url.pathname){\n            case \"/authorize/\":\n                if ($982c9e81107e6258$var$error = $16ZAN$muzenlassert.fails(url.searchParams, {\n                    response_type: \"code\",\n                    client_id: \"mockClientId\",\n                    state: $16ZAN$muzenlassert.Optional(/.*/)\n                })) return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$badRequest($982c9e81107e6258$var$error));\n                if (url.searchParams.has(\"code_challenge\")) {\n                    if (!url.searchParams.has(\"code_challenge_method\")) return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$badRequest(\"missing code_challenge_method\"));\n                    $982c9e81107e6258$var$pkce.code_challenge = url.searchParams.get(\"code_challenge\");\n                    pcke.code_challenge_method = url.searchParams.get(\"code_challenge_method\");\n                }\n                return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$baseResponse, {\n                    body: JSON.stringify({\n                        code: \"mockAuthorizeToken\",\n                        state: url.searchParams.get(\"state\")\n                    })\n                });\n            case \"/token/\":\n                if ($982c9e81107e6258$var$error = $16ZAN$muzenlassert.fails(url.searchParams, {\n                    grant_type: $16ZAN$muzenlassert.oneOf(\"refresh_token\", \"authorization_code\")\n                })) return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$badRequest($982c9e81107e6258$var$error));\n                switch(url.searchParams.grant_type){\n                    case \"refresh_token\":\n                        if ($982c9e81107e6258$var$error = $16ZAN$muzenlassert.fails(url.searchParams, $16ZAN$muzenlassert.oneOf({\n                            refresh_token: \"mockRefreshToken\",\n                            client_id: \"mockClientId\",\n                            client_secret: \"mockClientSecret\"\n                        }, {\n                            refresh_token: \"mockRefreshToken\",\n                            client_id: \"mockClientId\",\n                            code_verifier: /.+/\n                        }))) return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$badRequest($982c9e81107e6258$var$error));\n                        break;\n                    case \"access_token\":\n                        if ($982c9e81107e6258$var$error = $16ZAN$muzenlassert.fails(url.searchParams, $16ZAN$muzenlassert.oneOf({\n                            client_id: \"mockClientId\",\n                            client_secret: \"mockClientSecret\"\n                        }, {\n                            client_id: \"mockClientId\",\n                            code_challenge: /.*/,\n                            code_challenge_method: \"S256\"\n                        }))) return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$badRequest($982c9e81107e6258$var$error));\n                        break;\n                }\n                return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$baseResponse, {\n                    body: JSON.stringify({\n                        access_token: \"mockAccessToken\",\n                        token_type: \"mockExample\",\n                        expires_in: 3600,\n                        refresh_token: \"mockRefreshToken\",\n                        example_parameter: \"mockExampleValue\"\n                    })\n                });\n            case \"/protected/\":\n                let auth = req.headers.get(\"Authorization\");\n                let [type, token] = auth ? auth.split(\" \") : [];\n                if (!token || token !== \"mockAccessToken\") return $16ZAN$muzenlmetro.response({\n                    status: 401,\n                    statusText: \"Forbidden\",\n                    body: \"401 Forbidden\"\n                });\n                return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$baseResponse, {\n                    body: JSON.stringify({\n                        result: \"Success\"\n                    })\n                });\n            case \"/public/\":\n                return $16ZAN$muzenlmetro.response($982c9e81107e6258$var$baseResponse, {\n                    body: JSON.stringify({\n                        result: \"Success\"\n                    })\n                });\n            default:\n                return $16ZAN$muzenlmetro.response({\n                    status: 404,\n                    statusText: \"not found\",\n                    body: \"404 Not Found \" + url\n                });\n        }\n    };\n}\n\n\nvar $974eb00238334f87$exports = {};\n\n$parcel$defineInteropFlag($974eb00238334f87$exports);\n\n$parcel$export($974eb00238334f87$exports, \"default\", () => $974eb00238334f87$export$2e2bcd8739ae039);\n\nfunction $974eb00238334f87$export$2e2bcd8739ae039(options) {\n    let code_challenge;\n    let pkce = {\n        code_verifier: \"\",\n        endpoints: {\n            authorize: \"/authorize\",\n            token: \"/token\"\n        }\n    };\n    if (options?.endpoints?.authorize) pkce.endpoints.authorize = options.endpoints.authorize;\n    if (options?.endpoints?.token) pkce.endpoints.token = options.endpoints.token;\n    if (options.code_verifier) pkce.code_verifier = options.code_verifier;\n    else // TODO: allow code_verifier to be saved\n    pkce.code_verifier = crypto.randomBytes(64).toString(\"hex\");\n    return async function(req, next) {\n        // check if req needs to be altered with code_verifier or code_challenge\n        req.url = $16ZAN$muzenlmetro.url(req.url);\n        if (req.url.pathname == pkce.endpoints.authorize) {\n            req.url.searchParams.set(\"code_challenge\", generateCodeChallenge(options.code_verifier));\n            req.url.searchParams.set(\"code_challend_method\", \"S256\");\n            req.url.searchParams.delete(\"client_secret\");\n        } else if (req.url.pathname == pkce.endpoints.token) {\n            req.url.searchParams.set(\"code_verifier\", pkce.code_verifier);\n            req.url.searchParams.delete(\"client_secret\");\n        }\n        return await next(req);\n    };\n    /**\n\t * Returns a PKCE code_challenge derived from a code_verifier\n\t */ async function generateCodeChallenge(code_verifier) {\n        return await globalThis.crypto.subtle.digest(\"SHA-256\", base64url_encode(code_verifier));\n    }\n    /**\n\t * Base64url encoding, which handles UTF-8 input strings correctly.\n\t */ function base64url_encode(buffer) {\n        const byteString = Array.from(new Uint8Array(buffer), (b)=>String.fromCharCode(b)).join(\"\");\n        return btoa(byteString).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    }\n}\n\n\nvar $feb00dcd929419f4$exports = {};\n\n$parcel$defineInteropFlag($feb00dcd929419f4$exports);\n\n$parcel$export($feb00dcd929419f4$exports, \"default\", () => $feb00dcd929419f4$export$2e2bcd8739ae039);\n\n\n\n\n\n// import mwOauth2DPoP from './oauth2.DPoP.mjs'\n/**\n * This module allows for oauth2 discovery and returns an oauth2\n * client with all required middleware and options configured\n * \n * oauth2 discovery: https://datatracker.ietf.org/doc/html/rfc8414\n */ const $feb00dcd929419f4$var$MustNotHave = (...options1)=>(value, root)=>options1.filter((o)=>root.hasOwnKey(o)).length == 0;\n//FIXME: list valid algorithms per usecase, these are for JWK\nconst $feb00dcd929419f4$var$validAlgorithms = [\n    \"HS256\",\n    \"HS384\",\n    \"HS512\",\n    \"RS256\",\n    \"RS384\",\n    \"RS512\",\n    \"ES256\",\n    \"ES384\",\n    \"ES512\"\n];\n//FIXME: other auth methods may be defined by extensions to openid connect discovery\nconst $feb00dcd929419f4$var$validAuthMethods = [\n    \"client_secret_post\",\n    \"client_secret_base\",\n    \"client_secret_jwt\",\n    \"private_key_jwt\"\n];\nconst $feb00dcd929419f4$var$oauth_authorization_server_metadata = {\n    issuer: (0, $16ZAN$muzenlassert.Required)(validURL),\n    authorization_endpoint: (0, $16ZAN$muzenlassert.Required)(validURL),\n    token_endpoint: (0, $16ZAN$muzenlassert.Required)(validURL),\n    jwks_uri: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    registration_endpoint: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    scopes_supported: (0, $16ZAN$muzenlassert.Recommended)([]),\n    response_types_supported: (0, $16ZAN$muzenlassert.Required)((0, $16ZAN$muzenlassert.anyOf)(\"code\", \"token\")),\n    response_modes_supported: (0, $16ZAN$muzenlassert.Optional)([]),\n    grant_types_supported: (0, $16ZAN$muzenlassert.Optional)([]),\n    token_endpoint_auth_methods_supported: (0, $16ZAN$muzenlassert.Optional)([]),\n    token_endpoint_auth_signing_alg_values_supported: (0, $16ZAN$muzenlassert.Optional)([]),\n    service_documentation: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    ui_locales_supported: (0, $16ZAN$muzenlassert.Optional)([]),\n    op_policy_uri: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    op_tos_uri: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    revocation_endpoint: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    revocation_endpoint_auth_methods_supported: (0, $16ZAN$muzenlassert.Optional)($feb00dcd929419f4$var$validAuthMethods),\n    revocation_endpoint_auth_signing_alg_values_supported: (0, $16ZAN$muzenlassert.Optional)($feb00dcd929419f4$var$validAlgorithms),\n    introspection_endpoint: (0, $16ZAN$muzenlassert.Optional)(validURL),\n    introspection_endpoint_auth_methods_supported: (0, $16ZAN$muzenlassert.Optional)($feb00dcd929419f4$var$validAuthMethods),\n    introspection_endpoint_auth_signing_alg_values_supported: (0, $16ZAN$muzenlassert.Optional)($feb00dcd929419f4$var$validAlgorithms),\n    code_challendge_methods_supported: (0, $16ZAN$muzenlassert.Optional)([])\n};\nfunction $feb00dcd929419f4$export$2e2bcd8739ae039(options1 = {}) {\n    const defaultOptions = {\n        client: $16ZAN$muzenlmetro.client()\n    };\n    options1 = Object.assign({}, defaultOptions, options1);\n    (0, $16ZAN$muzenlassert.assert)(options1, {\n        issuer: (0, $16ZAN$muzenlassert.Required)(validURL)\n    });\n    // start discovery\n    const oauth_authorization_server_configuration = $feb00dcd929419f4$var$fetchWellknownOauthAuthorizationServer(options1.issuer);\n    let client = options1.client.with(options1.issuer);\n}\nasync function $feb00dcd929419f4$var$fetchWellknownOauthAuthorizationServer(issuer) {\n    let res = options.client.get($16ZAN$muzenlmetro.url(issuer, \".wellknown/oauth_authorization_server\"));\n    if (res.ok) {\n        (0, $16ZAN$muzenlassert.assert)(res.headers.get(\"Content-Type\"), /application\\/json.*/);\n        let configuration = await res.json();\n        (0, $16ZAN$muzenlassert.assert)(configuration, $feb00dcd929419f4$var$oauth_authorization_server_metadata);\n        return configuration;\n    }\n    throw $16ZAN$muzenlmetro.metroError(\"metro.oidcmw: Error while fetching \" + issuer + \".wellknown/oauth_authorization_server\", res);\n}\n\n\nglobalThis.oauth2 = $dcc128ad0af646ff$exports;\nglobalThis.oauth2.mockserver = $982c9e81107e6258$exports;\nglobalThis.oauth2.pkce = $974eb00238334f87$exports;\nglobalThis.oauth2.discovery = $feb00dcd929419f4$exports;\n\n\n//# sourceMappingURL=browser.js.map\n","import * as oauth2 from './oauth2.mjs'\nimport * as oauth2mockserver from './oauth2.mockserver.mjs'\nimport * as oauth2pkce from './oauth2.pkce.mjs'\nimport * as oauth2discovery from './oauth2.discovery.mjs'\n\nglobalThis.oauth2 = oauth2\nglobalThis.oauth2.mockserver = oauth2mockserver\nglobalThis.oauth2.pkce = oauth2pkce\nglobalThis.oauth2.discovery = oauth2discovery\n","import * as metro from '@muze-nl/metro'\nimport * as assert from '@muze-nl/assert'\nimport jsonmw from '@muze-nl/metro/src/mw/json.mjs'\n\n/**\n * oauth2mw returns a middleware for @muze-nl/metro that\n * implements oauth2 authentication in the metro client.\n * it supports the authorization_code, refresh_token and\n * client_credentials grant_type.\n * Since implicit flow is deemed insecure, it is not supported\n * (see the OAuth2.1 RFC)\n */\n\nexport default function mwOAuth2(options) {\n\n\tlet site = 'default'\n\tif (options.site) {\n\t\tsite = options.site\n\t}\n\n\tlet localState, localTokens\n\tif (typeof localStorage !== 'undefined') {\n\t\tlocalState = {\n\t\t\tget: () => localStorage.getItem('metro/state:'+site),\n\t\t\thas: () => localStorage.getItem('metro/state:'+site),\n\t\t\tset: (value) => localStorage.setItem('metro/state:'+site, value)\n\t\t}\n\t\tlocalTokens = {\n\t\t\tget: (name) => localStorage.getItem(site+':'+name),\n\t\t\tset: (name, value) => localStorage.setItem(site+':'+name, value),\n\t\t\thas: (name) => localStorage.hasItem(site+':'+name)\n\t\t}\n\t} else {\n\t\tlet stateMap = new Map()\n\t\tlocalState = {\n\t\t\tget: () => stateMap.get('metro/state:'+site),\n\t\t\thas: () => stateMap.get('metro/state:'+site),\n\t\t\tset: (value) => stateMap.set('metro/state:'+site, value)\n\t\t}\n\t\tlocalTokens = new Map()\n\t}\n\n\tconst oauth2 = {\n\t\ttokens: localTokens,\n\t\tstate: localState,\n\t\tendpoints: {\n\t\t\tauthorize: '/authorize',\n\t\t\ttoken: '/token'\n\t\t},\n\t\tcallbacks: {\n\t\t\tauthorize: url => document.location = url\n\t\t},\n\t\tclient: metro.client().with(jsonmw()),\n\t\tclient_id: '',\n\t\tclient_secret: '',\n\t\tredirect_uri: '',\n\t\tgrant_type: 'authorization_code',\n\t\tforce_authorization: false\n\t}\n\n\tfor (let option in options) {\n\t\tswitch(option) {\n\t\t\tcase 'access_token':\n\t\t\tcase 'authorization_code':\n\t\t\tcase 'refresh_token':\n\t\t\t\toauth2.tokens.set(option, options[option])\n\t\t\tbreak\n\n\t\t\tcase 'client':\n\t\t\tcase 'client_id':\n\t\t\tcase 'client_secret':\n\t\t\tcase 'grant_type':\n\t\t\tcase 'force_authorization':\n\t\t\tcase 'redirect_uri':\n\t\t\t\toauth2[option] = options[option]\n\t\t\tbreak\n\t\t\tcase 'state':\n\t\t\tcase 'tokens':\n\t\t\t\tif (typeof options[option].set == 'function' && \n\t\t\t\t\ttypeof options[option].get == 'function' && \n\t\t\t\t\ttypeof options[option].has == 'function' ) {\n\t\t\t\t\toauth2[option] = options[option]\n\t\t\t\t} else if (option == 'tokens' && typeof options.tokens == 'object') {\n\t\t\t\t\tfor (let token in options.tokens) {\n\t\t\t\t\t\toauth2.tokens.set(token, options.tokens[token])\n\t\t\t\t\t}\n\t\t\t\t} else if (option == 'state' && typeof options.state == 'object') {\n\t\t\t\t\tif (!options.state.random) {\n\t\t\t\t\t\toptions.state.random = createState(40)\n\t\t\t\t\t}\n\t\t\t\t\toauth2.state.set(JSON.stringify(options.state))\n\t\t\t\t} else {\n\t\t\t\t\tthrow metro.metroError('metro/mw/oauth2: incorrect value for '+option)\n\t\t\t\t}\n\t\t\tbreak\n\t\t\tcase 'endpoints':\n\t\t\t\tfor (let endpoint in options.endpoints) {\n\t\t\t\t\tif (endpoint!='authorize' && endpoint!='token') {\n\t\t\t\t\t\tthrow metro.metroError('Unknown endpoint, choose one of \"authorize\" or \"token\"',endpoint)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tObject.assign(oauth2.endpoints, options.endpoints)\n\t\t\tbreak\n\t\t\tcase 'callbacks':\n\t\t\t\tfor (let callback in options.callbacks) {\n\t\t\t\t\tif (callback != 'authorize') {\n\t\t\t\t\t\tthrow metro.metroError('Unknown callback, choose one of \"authorize\"',callback)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tObject.assign(oauth2.callbacks, options.callbacks)\n\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow metro.metroError('Unknown oauth2mw option ',option)\n\t\t\tbreak\n\t\t}\n\t\tif (!oauth2.redirect_uri) {\n\t\t\toauth2.redirect_uri = typeof window !== 'undefined' ? window.location?.href : ''\n\t\t}\n\t\tif (oauth2.redirect_uri) {\n\t\t\toauth2.redirect_uri = metro.url(oauth2.redirect_uri).with('?metroRedirect=true')\n\t\t}\n\t}\n\n\t/**\n\t * This is the middleware function. It will intercept a request, and if needed\n\t * go through the OAuth2 authorization flow first.\n\t */\n\treturn async function(req, next) {\n\t\tif (oauth2.force_authorization) {\n\t\t\treturn oauth2authorized(req, next)\n\t\t}\n\t\tlet res = await next(req)\n\t\tif (res.ok) {\n\t\t\treturn res\n\t\t}\n\t\tswitch(res.status) {\n\t\t\tcase 400:\n\t\t\tcase 401:\n\t\t\t\treturn oauth2authorized(req, next)\n\t\t\tbreak\n\t\t}\n\t\treturn res\n\t}\n\n\t/**\n\t * Implements the OAuth2 authorization flow for a request\n\t */\n\tasync function oauth2authorized(req, next) {\n\t\tgetTokensFromLocation()\n\t\tif (!oauth2.tokens.has('access_token')) {\n\t\t\tlet token = await fetchAccessToken(req)\n\t\t\tif (!token) {\n\t\t\t\treturn metro.response('false')\n\t\t\t}\n\t\t\treturn oauth2authorized(req, next)\n\t\t} else if (isExpired(req)) {\n\t\t\tlet token = await fetchRefreshToken(req)\n\t\t\tif (!token) {\n\t\t\t\treturn metro.response('false')\n\t\t\t}\n\t\t\treturn oauth2authorized(req, next)\n\t\t} else {\n\t\t\tlet accessToken = oauth2.tokens.get('access_token')\n\t\t\treq = metro.request(req, {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: accessToken.type+' '+accessToken.value\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn next(req)\n\t\t}\n\t}\n\n\t/**\n\t * Fetches and stores the authorization_code from a redirected URI\n\t * Then removes the authorization_code from the browser URL\n\t */\n\tfunction getTokensFromLocation() {\n\t\tif (typeof window !== 'undefined' && window?.location) {\n\t\t\tlet url = metro.url(window.location)\n\t\t\tlet code, state, params\n\t\t\tif (url.searchParams.has('code')) {\n\t\t\t\tparams = url.searchParams\n\t\t\t\turl = url.with({ search:'' })\n\t\t\t\thistory.pushState({},'',url.href)\n\t\t\t} else if (url.hash) {\n\t\t\t\tlet query = url.hash.substr(1)\n\t\t\t\tparams = new URLSearchParams('?'+query)\n\t\t\t\turl = url.with({ hash:'' })\n\t\t\t\thistory.pushState({},'',url.href)\n\t\t\t}\n\t\t\tif (params) {\n\t\t\t\tcode = params.get('code')\n\t\t\t\tstate = params.get('state')\n\t\t\t\tlet storedState = oauth2.state.get('metro/state')\n\t\t\t\tif (!state || state!==storedState) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (code) {\n\t\t\t\t\toauth2.tokens.set('authorization_code', code)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fetches the access_token. If the authorization_code hasn't been retrieved yet,\n\t * it will first try to get that, using the oauth2.callbacks.authorize function.\n\t * If a refresh_token is also returned, it will store that in the oauth2.tokens storage.\n\t */\n\tasync function fetchAccessToken(req) {\n\t\tif (oauth2.grant_type === 'authorization_code' && !oauth2.tokens.has('authorization_code')) {\n\t\t\tlet authReqURL = getAuthorizationCodeURL()\n\t\t\tif (!oauth2.callbacks.authorize || typeof oauth2.callbacks.authorize !== 'function') {\n\t\t\t\tthrow metro.metroError('oauth2mw: oauth2 with grant_type:authorization_code requires a callback function in client options.oauth2.callbacks.authorize')\n\t\t\t}\n\t\t\tlet token = await oauth2.callbacks.authorize(authReqURL)\n\t\t\tif (token) {\n\t\t\t\toauth2.tokens.set('authorization_code', token)\n\t\t\t} else {\n\t\t\t\treturn metro.response(false)\n\t\t\t}\n\t\t}\n\t\tlet tokenReq = getAccessTokenURL()\n\t\tlet response = await oauth2.client.get(tokenReq)\n\t\tif (!response.ok) {\n\t\t\tthrow metro.metroError(response.status+':'+response.statusText, await response.text())\n\t\t}\n\t\tlet data = await response.json()\n\t\toauth2.tokens.set('access_token', {\n\t\t\tvalue: data.access_token,\n\t\t\texpires: getExpires(data.expires_in),\n\t\t\ttype: data.token_type,\n\t\t\tscope: data.scope\n\t\t})\n\t\tif (data.refresh_token) {\n\t\t\tlet token = {\n\t\t\t\tvalue: data.refresh_token\n\t\t\t}\n\t\t\toauth2.tokens.set('refresh_token', token)\n\t\t}\n\t\treturn data\n\t}\n\n\t/**\n\t * Fetches a new access_token using a stored refresh_token\n\t * If a new refresh_token is also returned, it will update the stored refresh_token\n\t */\n\tasync function fetchRefreshToken(req, next)\n\t{\n\t\tlet refreshTokenReq = getAccessTokenURL('refresh_token')\n\t\tlet response = await oauth2.client.get(refreshTokenReq)\n\t\tif (!response.ok) {\n\t\t\tthrow metro.metroError(response.status+':'+response.statusText, await response.text())\n\t\t}\n\t\tlet data = await response.json()\n\t\toauth2.tokens.set('access_token', {\n\t\t\tvalue:   data.access_token,\n\t\t\texpires: getExpires(data.expires_in),\n\t\t\ttype:    data.token_type,\n\t\t\tscope:   data.scope\n\t\t})\n\t\tif (data.refresh_token) {\n\t\t\tlet token = {\n\t\t\t\tvalue: data.refresh_token\n\t\t\t}\n\t\t\toauth2.tokens.set('refresh_token', token)\n\t\t}\n\t\treturn data\n\t}\n\n\t/**\n\t * Returns the URL to use to get a authorization_code\n\t */\n\tfunction getAuthorizationCodeURL() {\n\t\tif (!oauth2.endpoints.authorize) {\n\t\t\tthrow metro.metroError('oauth2mw: Missing options.endpoints.authorize url')\n\t\t}\n\t\tlet url = metro.url(oauth2.endpoints.authorize, {hash: ''})\n\t\tassert.assert(oauth2, {\n\t\t\tclient_id: /.+/,\n\t\t\tredirect_uri: /.+/,\n\t\t\tscope: /.*/\n\t\t})\n\t\tlet search = {\n\t\t\tresponse_type: 'code', // implicit flow uses 'token' here, but is not considered safe, so not supported\n\t\t\tclient_id:     oauth2.client_id,\n\t\t\tredirect_uri:  oauth2.redirect_uri,\n\t\t\tstate:         oauth2.state || createState(40)\n\t\t}\n\t\tsearch.client_secret = oauth2.client_secret\n\t\tif (oauth2.scope) {\n\t\t\tsearch.scope = oauth2.scope\n\t\t}\n\t\treturn metro.url(url, { search })\n\t}\n\n\t/**\n\t * Creates and stores a random state to use in the authorization code URL\n\t */\n\tfunction createState(length) {\n\t\tconst validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n\t\tlet randomState = ''\n\t\tlet counter = 0\n\t    while (counter < length) {\n\t        randomState += validChars.charAt(Math.floor(Math.random() * validChars.length))\n\t        counter++\n\t    }\n\t\toauth2.state.set(randomState)\n\t\treturn randomState\n\t}\n\n\t/**\n\t * Returns a token endpoint URL with all the correct parameters, given the\n\t * grant_type. This can then be used in a metro.get.\n\t */\n\tfunction getAccessTokenURL(grant_type=null) {\n\t\tassert.assert(oauth2, {\n\t\t\tclient_id: /.+/,\n\t\t\tredirect_uri: /.+/\n\t\t})\n\t\tif (!oauth2.endpoints.token) {\n\t\t\tthrow metro.metroError('oauth2mw: Missing options.endpoints.token url')\n\t\t}\n\t\tlet url = metro.url(oauth2.endpoints.token, {hash: ''})\n\t\tlet params = {\n\t\t\tgrant_type: grant_type || oauth2.grant_type,\n\t\t\tclient_id:  oauth2.client_id\n\t\t}\n\t\tparams.client_secret = oauth2.client_secret\n\t\tif (oauth2.scope) {\n\t\t\tparams.scope = oauth2.scope\n\t\t}\n\t\tswitch(oauth2.grant_type) {\n\t\t\tcase 'authorization_code':\n\t\t\t\tparams.redirect_uri = oauth2.redirect_uri\n\t\t\t\tparams.code = oauth2.tokens.get('authorization_code')\n\t\t\tbreak\n\t\t\tcase 'client_credentials':\n\t\t\t\t// nothing to add\n\t\t\tbreak\n\t\t\tcase 'refresh_token':\n\t\t\t\tparams.refresh_token = oauth2.refresh_token\n\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown grant_type: '.oauth2.grant_type)\n\t\t\tbreak\n\t\t}\n\t\treturn metro.url(url, {\n\t\t\tsearchParams: params\n\t\t})\n\t}\n\n\t/**\n\t * Returns true if the access token in a request is expired. False otherwise.\n\t */\n\tfunction isExpired(req) {\n\t\tif (req.oauth2 && req.oauth2.tokens && req.oauth2.tokens.has('access_token')) {\n\t\t\tlet now = new Date();\n\t\t\tlet token = req.oauth2.tokens.get('access_token')\n\t\t\treturn now.getTime() > token.expires.getTime();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a new Date based on a duration, which can either be a date\n\t * or a number of seconds from now.\n\t */\n\tfunction getExpires(duration) {\n\t\tif (duration instanceof Date) {\n\t\t\treturn new Date(duration.getTime()); // return a copy\n\t\t}\n\t\tif (typeof duration === 'number') {\n\t\t\tlet date = new Date();\n\t\t\tdate.setSeconds(date.getSeconds() + duration);\n\t\t\treturn date;\n\t\t}\n\t\tthrow new TypeError('Unknown expires type '+duration);\n\t}\n}","import * as metro from '@muze-nl/metro'\nimport * as assert from '@muze-nl/assert'\n\nconst baseResponse = {\n\tstatus: 200,\n\tstatusText: 'OK',\n\theaders: {\n\t\t'Content-Type':'application/json'\n\t}\n}\n\nconst badRequest = (error) => {\n\treturn {\n\t\tstatus: 400,\n\t\tstatusText: 'Bad Request',\n\t\theaders: {\n\t\t\t'Content-Type':'application/json'\n\t\t},\n\t\tbody: JSON.stringify({\n\t\t\terror: 'invalid_request',\n\t\t\terror_description: error\n\t\t})\n\t}\n}\n\nlet error, expect, token\nlet pkce = {}\n\nexport default function oauth2mockserver(options={}) {\n\n\t// TODO: add PCKE support, so assert either client_secret or code_verifier / code_challenge\n\t// store code_challenge and code_challenge_method for each authorization_code\n\t// TODO: add DPoP support\n\tconst defaultOptions = {\n\t\t'PKCE': false,\n\t\t'DPoP': false\n\t}\n\toptions = Object.assign({}, defaultOptions, options)\n\n\treturn (req, next) => {\n\t\tlet url = metro.url(req.url)\n\t\tswitch(url.pathname) {\n\t\t\tcase '/authorize/':\n\t\t\t\tif (error = assert.fails(url.searchParams, {\n\t\t\t\t\tresponse_type: 'code',\n\t\t\t\t\tclient_id: 'mockClientId',\n\t\t\t\t\tstate: assert.Optional(/.*/)\n\t\t\t\t})) {\n\t\t\t\t\treturn metro.response(badRequest(error))\n\t\t\t\t}\n\t\t\t\tif (url.searchParams.has('code_challenge')) {\n\t\t\t\t\tif (!url.searchParams.has('code_challenge_method')) {\n\t\t\t\t\t\treturn metro.response(badRequest('missing code_challenge_method'))\n\t\t\t\t\t}\n\t\t\t\t\tpkce.code_challenge = url.searchParams.get('code_challenge')\n\t\t\t\t\tpcke.code_challenge_method = url.searchParams.get('code_challenge_method')\n\t\t\t\t}\n\t\t\t\treturn metro.response(baseResponse, {\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tcode: 'mockAuthorizeToken',\n\t\t\t\t\t\tstate: url.searchParams.get('state')\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\tbreak\n\t\t\tcase '/token/':\n\t\t\t\tif (error = assert.fails(url.searchParams, {\n\t\t\t\t\tgrant_type: assert.oneOf('refresh_token','authorization_code')\n\t\t\t\t})) {\n\t\t\t\t\treturn metro.response(badRequest(error))\n\t\t\t\t}\n\t\t\t\tswitch(url.searchParams.grant_type) {\n\t\t\t\t\tcase 'refresh_token':\n\t\t\t\t\t\tif (error = assert.fails(url.searchParams, assert.oneOf({\n\t\t\t\t\t\t\trefresh_token: 'mockRefreshToken',\n\t\t\t\t\t\t\tclient_id: 'mockClientId',\n\t\t\t\t\t\t\tclient_secret: 'mockClientSecret'\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\trefresh_token: 'mockRefreshToken',\n\t\t\t\t\t\t\tclient_id: 'mockClientId',\n\t\t\t\t\t\t\tcode_verifier: /.+/\n\t\t\t\t\t\t}))) {\n\t\t\t\t\t\t\treturn metro.response(badRequest(error))\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t\tcase 'access_token':\n\t\t\t\t\t\tif (error = assert.fails(url.searchParams, assert.oneOf({\n\t\t\t\t\t\t\tclient_id: 'mockClientId',\n\t\t\t\t\t\t\tclient_secret: 'mockClientSecret'\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tclient_id: 'mockClientId',\n\t\t\t\t\t\t\tcode_challenge: /.*/, //FIXME: check that this matches code_verifier\n\t\t\t\t\t\t\tcode_challenge_method: 'S256'\n\t\t\t\t\t\t}))) {\n\t\t\t\t\t\t\treturn metro.response(badRequest(error))\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn metro.response(baseResponse, {\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\taccess_token: 'mockAccessToken',\n\t\t\t\t\t\ttoken_type: 'mockExample',\n\t\t\t\t\t\texpires_in: 3600,\n\t\t\t\t\t\trefresh_token: 'mockRefreshToken',\n\t\t\t\t\t\texample_parameter: 'mockExampleValue'\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\tbreak\n\t\t\tcase '/protected/':\n\t\t\t\tlet auth = req.headers.get('Authorization')\n\t\t\t\tlet [type,token] = auth ? auth.split(' ') : []\n\t\t\t\tif (!token || token!=='mockAccessToken') {\n\t\t\t\t\treturn metro.response({\n\t\t\t\t\t\tstatus: 401,\n\t\t\t\t\t\tstatusText: 'Forbidden',\n\t\t\t\t\t\tbody: '401 Forbidden'\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn metro.response(baseResponse, {\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tresult: 'Success'\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\tbreak\n\t\t\tcase '/public/':\n\t\t\t\treturn metro.response(baseResponse, {\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tresult: 'Success'\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\treturn metro.response({\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\tstatusText: 'not found',\n\t\t\t\t\tbody: '404 Not Found '+url\n\t\t\t\t})\n\t\t\tbreak\n\t\t}\n\t}\n}","import * as metro from '@muze-nl/metro'\n\nexport default function mwOAuth2PKCE(options)\n{\n\tlet code_challenge\n\n\tlet pkce = {\n\t\tcode_verifier: '',\n\t\tendpoints: {\n\t\t\tauthorize: '/authorize',\n\t\t\ttoken: '/token'\n\t\t}\n\t}\n\n\tif (options?.endpoints?.authorize) {\n\t\tpkce.endpoints.authorize = options.endpoints.authorize\n\t}\n\n\tif (options?.endpoints?.token) {\n\t\tpkce.endpoints.token = options.endpoints.token\n\t}\n\n\tif (options.code_verifier) {\n\t\tpkce.code_verifier = options.code_verifier\n\t} else {\n\t\t// TODO: allow code_verifier to be saved\n\t\tpkce.code_verifier = crypto.randomBytes(64).toString('hex');\n\t}\n\n\treturn async function(req, next) {\n\t\t// check if req needs to be altered with code_verifier or code_challenge\n\t\treq.url = metro.url(req.url)\n\t\tif (req.url.pathname == pkce.endpoints.authorize) {\n\t\t\treq.url.searchParams.set('code_challenge', generateCodeChallenge(options.code_verifier))\n\t\t\treq.url.searchParams.set('code_challend_method', 'S256');\n\t\t\treq.url.searchParams.delete('client_secret')\n\t\t} else if (req.url.pathname == pkce.endpoints.token) {\n\t\t\treq.url.searchParams.set('code_verifier', pkce.code_verifier)\n\t\t\treq.url.searchParams.delete('client_secret')\n\t\t}\n\t\treturn await next(req)\n\t}\n\n\t/**\n\t * Returns a PKCE code_challenge derived from a code_verifier\n\t */\n\tasync function generateCodeChallenge(code_verifier) {\n\t\treturn await globalThis.crypto.subtle.digest('SHA-256', base64url_encode(code_verifier))\n\t}\n\n\t/**\n\t * Base64url encoding, which handles UTF-8 input strings correctly.\n\t */\n\tfunction base64url_encode(buffer) {\n\t\tconst byteString = Array.from(new Uint8Array(buffer), b => String.fromCharCode(b)).join('')\n\t    return btoa(byteString)\n\t        .replace(/\\+/g, '-')\n\t        .replace(/\\//g, '_')\n\t        .replace(/=+$/, '');\n\t}\n}","import * as metro from '@muze-nl/metro'\nimport { assert, Required, Recommended, Optional, oneOf, anyOf } from '@muze-nl/assert'\nimport jsonmw from '@muze-nl/metro/src/mw/json.mjs'\nimport mwOauth2 from './oauth2.mjs'\nimport mwOAuth2PKCE from './oauth2.pkce.mjs'\n// import mwOauth2DPoP from './oauth2.DPoP.mjs'\n\n/**\n * This module allows for oauth2 discovery and returns an oauth2\n * client with all required middleware and options configured\n * \n * oauth2 discovery: https://datatracker.ietf.org/doc/html/rfc8414\n */\n\nconst MustNotHave = (...options) => \n\t(value, root) => options.filter(o => root.hasOwnKey(o)).length == 0\n\n//FIXME: list valid algorithms per usecase, these are for JWK\nconst validAlgorithms = [\n\t'HS256','HS384','HS512','RS256','RS384','RS512','ES256','ES384','ES512'\n]\n//FIXME: other auth methods may be defined by extensions to openid connect discovery\nconst validAuthMethods = [\n\t'client_secret_post', 'client_secret_base','client_secret_jwt','private_key_jwt'\n]\n\nconst oauth_authorization_server_metadata = {\n\tissuer: Required(validURL),\n\tauthorization_endpoint: Required(validURL),\n\ttoken_endpoint: Required(validURL),\n\tjwks_uri: Optional(validURL),\n\tregistration_endpoint: Optional(validURL),\n\tscopes_supported: Recommended([]),\n\tresponse_types_supported: Required(anyOf('code','token')),\n\tresponse_modes_supported: Optional([]),\n\tgrant_types_supported: Optional([]),\n\ttoken_endpoint_auth_methods_supported: Optional([]),\n\ttoken_endpoint_auth_signing_alg_values_supported: Optional([]),\n\tservice_documentation: Optional(validURL),\n\tui_locales_supported: Optional([]),\n\top_policy_uri: Optional(validURL),\n\top_tos_uri: Optional(validURL),\n\trevocation_endpoint: Optional(validURL),\n\trevocation_endpoint_auth_methods_supported: Optional(validAuthMethods),\n\trevocation_endpoint_auth_signing_alg_values_supported: Optional(validAlgorithms),\n\tintrospection_endpoint: Optional(validURL),\n\tintrospection_endpoint_auth_methods_supported: Optional(validAuthMethods),\n\tintrospection_endpoint_auth_signing_alg_values_supported: Optional(validAlgorithms),\n\tcode_challendge_methods_supported: Optional([])\n}\n\nexport default function makeClient(options={}) {\n\tconst defaultOptions = {\n\t\tclient: metro.client()\n\t}\n\toptions = Object.assign({}, defaultOptions, options)\n\tassert(options, {\n\t\tissuer: Required(validURL)\n\t})\n\n\t// start discovery\n\tconst oauth_authorization_server_configuration = fetchWellknownOauthAuthorizationServer(options.issuer)\n\tlet client = options.client.with(options.issuer)\n}\n\nasync function fetchWellknownOauthAuthorizationServer(issuer)\n{\n\tlet res = options.client.get(metro.url(issuer,'.wellknown/oauth_authorization_server'))\n\tif (res.ok) {\n\t\tassert(res.headers.get('Content-Type'), /application\\/json.*/)\n\t\tlet configuration = await res.json()\n\t\tassert(configuration, oauth_authorization_server_metadata)\n\t\treturn configuration\n\t}\n\tthrow metro.metroError('metro.oidcmw: Error while fetching '+issuer+'.wellknown/oauth_authorization_server', res)\n}"],"names":["$982c9e81107e6258$var$error","$16ZAN$muzenlmetro","require","$16ZAN$muzenlassert","$16ZAN$muzenlmetrosrcmwjsonmjs","$parcel$defineInteropFlag","a","Object","defineProperty","value","configurable","$parcel$export","e","n","v","s","get","set","enumerable","$dcc128ad0af646ff$exports","$dcc128ad0af646ff$export$2e2bcd8739ae039","options","localState","localTokens","site","localStorage","getItem","has","setItem","name","hasItem","stateMap","Map","oauth2","tokens","state","endpoints","authorize","token","callbacks","url","document","location","client","with","__esModule","default","client_id","client_secret","redirect_uri","grant_type","force_authorization","option","random","createState","JSON","stringify","metroError","endpoint","assign","callback","window","href","req","next","oauth2authorized","res","ok","status","getTokensFromLocation","code","params","searchParams","search","history","pushState","hash","URLSearchParams","substr","storedState","isExpired","now","Date","getTime","expires","fetchRefreshToken","response","accessToken","request","headers","Authorization","type","fetchAccessToken","authReqURL","getAuthorizationCodeURL","assert","scope","response_type","tokenReq","getAccessTokenURL","statusText","text","data","json","access_token","getExpires","expires_in","token_type","refresh_token","refreshTokenReq","length","validChars","randomState","counter","charAt","Math","floor","Error","duration","date","setSeconds","getSeconds","TypeError","$982c9e81107e6258$exports","$982c9e81107e6258$export$2e2bcd8739ae039","$982c9e81107e6258$var$baseResponse","$982c9e81107e6258$var$badRequest","error","body","error_description","$982c9e81107e6258$var$pkce","pathname","fails","Optional","code_challenge","pcke","code_challenge_method","oneOf","code_verifier","example_parameter","auth","split","result","$974eb00238334f87$exports","$974eb00238334f87$export$2e2bcd8739ae039","pkce","crypto","randomBytes","toString","generateCodeChallenge","delete","globalThis","subtle","digest","btoa","Array","from","Uint8Array","b","String","fromCharCode","join","replace","$feb00dcd929419f4$exports","$feb00dcd929419f4$export$2e2bcd8739ae039","$feb00dcd929419f4$var$validAlgorithms","$feb00dcd929419f4$var$validAuthMethods","$feb00dcd929419f4$var$oauth_authorization_server_metadata","issuer","Required","validURL","authorization_endpoint","token_endpoint","jwks_uri","registration_endpoint","scopes_supported","Recommended","response_types_supported","anyOf","response_modes_supported","grant_types_supported","token_endpoint_auth_methods_supported","token_endpoint_auth_signing_alg_values_supported","service_documentation","ui_locales_supported","op_policy_uri","op_tos_uri","revocation_endpoint","revocation_endpoint_auth_methods_supported","revocation_endpoint_auth_signing_alg_values_supported","introspection_endpoint","introspection_endpoint_auth_methods_supported","introspection_endpoint_auth_signing_alg_values_supported","code_challendge_methods_supported","options1","$feb00dcd929419f4$var$fetchWellknownOauthAuthorizationServer","configuration","mockserver","discovery"],"version":3,"file":"browser.js.map","sourceRoot":"../"}